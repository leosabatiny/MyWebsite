<!-- clock-explainer.html -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Code Explainer â€“ Leonardo</title>
    <link rel="stylesheet" href="style.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-okaidia.min.css" rel="stylesheet" />
    <style>
        /* NEW LAYOUT: A single, clean column for code and explanations */
        #explainer-content {
            padding-top: 2rem;
            display: flex;
            flex-direction: column;
            gap: 2rem; /* Space between each code/explanation pair */
        }
        
        /* The container for a single code block */
        .code-block {
            border: 1px solid var(--border-color);
            border-radius: 8px 8px 0 0; /* Rounded top corners */
            overflow: hidden; /* Ensures content respects the border radius */
            background: var(--bg-surface); /* Give the container a background */
        }

        /* Prism.js styling */
        .code-block pre[class*="language-"] {
            margin: 0 !important;
            border-radius: 0 !important;
            background: transparent !important;
            white-space: pre-wrap;
            word-break: break-all;
            padding: 1rem;
        }
        
        /* The explanation box that attaches directly below its code block */
        .explanation-block {
            background-color: var(--bg-dark); /* A slightly different background */
            border: 1px solid var(--border-color);
            border-top: none; /* Merges with the code block above */
            border-radius: 0 0 8px 8px; /* Rounded bottom corners */
            padding: 1.5rem;
            margin-top: -1px; /* Overlaps the bottom border of the code block for a seamless look */
        }
        .explanation-block h3 {
            margin-top: 0;
            color: var(--text-primary);
        }
        .explanation-block p {
            color: var(--text-secondary);
            font-size: 0.95rem;
            margin: 0;
        }
    </style>
</head>
<body>
    <nav class="navbar">
        <div class="container">
            <a href="index.html" class="logo">Leonardo</a>
            <ul class="nav-links">
                <li><a href="index.html">Home</a></li>
                <li><a href="projects.html">Projects</a></li>
                <li><a href="clock.html">Back to Clock</a></li>
            </ul>
        </div>
    </nav>
    
    <div class="page-section">
        <div class="container">
            <h2>Clock Code Explainer</h2>
            <p>The code for the clock project is broken down into sections below, with a clear explanation for each block.</p>
            
            <!-- This container will be populated by the JavaScript -->
            <div id="explainer-content">
                <p>Loading code...</p>
            </div>
        </div>
    </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const explainerContent = document.getElementById('explainer-content');

            const explanations = {
                'setup': { title: 'Canvas & DOM Setup', text: 'This initial block sets up our "stage." It uses `getElementById` to get references to the HTML elements we need to control. `getContext("2d")` gives us the drawing tool for each canvas. We also read the site\'s theme colors from the CSS so our drawings match the website style.' },
                'fun-facts': { title: 'Fun Facts & Hover Logic', text: 'This creates the interactive hover feature. An array stores 24 facts, one for each hour. We then use `forEach` to attach event listeners to both clock canvases. `mouseenter` triggers when the mouse moves over a clock, displaying the correct fact for the current hour. `mouseleave` hides it again.' },
                'sizing': { title: 'Responsive Sizing', text: 'This function makes the clocks look good on any screen. It calculates a `baseUnit` from the window\'s width and height. It then uses this unit to set the canvas sizes, ensuring they scale proportionally. The `if` statement handles stacking the clocks vertically on smaller screens (like mobile) for better usability.' },
                'main-loop': { title: 'The Animation Loop', text: 'This is the heartbeat of the project. `requestAnimationFrame` creates a highly efficient loop that syncs with the screen\'s refresh rate (usually 60 times per second). Inside the loop, we get the current time and call the functions to redraw both clocks, creating perfectly smooth animation without wasting resources.' },
                'analog-clock': { title: 'Drawing the Analog Clock', text: 'This function draws the classic clock face. It uses `clearRect` to start with a blank slate each frame. `save()` and `restore()` are crucial for managing transformations. We use trigonometry (`Math.PI`) to calculate the precise angle for each hand to create the "ticking" motion and to place the numbers correctly around the dial.' },
                'draw-digit': { title: 'Drawing a Single Digit & Hands', text: 'These are our reusable "helper" functions. `drawHand` draws a single line for the analog clock. `drawDigit` is more complex: it uses the `segments` array as a blueprint. This array is a lookup table that maps a number (0-9) to a pattern of 7 "on" or "off" bars, which are then drawn as rectangles to form the digital glyph.' },
                'digital-clock': { title: 'Drawing the Digital Clock', text: 'This function handles the layout of the 7-segment display. It uses `padStart` to ensure single-digit numbers get a leading zero (e.g., "07"). The logic carefully calculates the start position (`startX`) to guarantee the entire block of numbers is always perfectly centered inside its container, regardless of size.' }
            };
            
            async function initializeExplainer() {
                try {
                    const response = await fetch('clock.html');
                    if (!response.ok) throw new Error('Network response was not ok');
                    const htmlText = await response.text();

                    const scriptMatch = htmlText.match(/<script>([\s\S]*?)<\/script>/);
                    if (!scriptMatch || !scriptMatch[1]) throw new Error('Script content not found.');
                    
                    const rawCode = scriptMatch[1].trim();
                    
                    // Clear the "Loading..." message
                    explainerContent.innerHTML = '';

                    const regionOrder = ['setup', 'fun-facts', 'sizing', 'main-loop', 'analog-clock', 'draw-digit', 'digital-clock'];

                    // Loop through the defined order to build the page
                    for (const key of regionOrder) {
                        const startMarker = `// REGION START: ${key}`;
                        const endMarker = `// REGION END: ${key}`;

                        // Use a reliable regex to extract the content between markers
                        const regionRegex = new RegExp(`${startMarker}[\\s\\S]*?${endMarker}`);
                        const match = rawCode.match(regionRegex);

                        if (match) {
                            // Clean up the extracted code by removing the markers themselves
                            let codeString = match[0].replace(startMarker, '').replace(endMarker, '').trim();
                            createCodeExplanationPair(key, codeString);
                        }
                    }

                    // Let Prism highlight all the code blocks we just created
                    Prism.highlightAll();

                } catch (error) {
                    console.error('Failed to load or process code:', error);
                    explainerContent.innerHTML = '<p>Failed to load code. Please ensure you are running this from a local server.</p>';
                }
            }

            function createCodeExplanationPair(key, codeString) {
                const explanation = explanations[key];
                if (!explanation) return;

                const codeBlockDiv = document.createElement('div');
                codeBlockDiv.className = 'code-block';
                const pre = document.createElement('pre');
                const code = document.createElement('code');
                code.className = 'language-javascript';
                code.textContent = codeString;
                pre.appendChild(code);
                codeBlockDiv.appendChild(pre);

                const explanationDiv = document.createElement('div');
                explanationDiv.className = 'explanation-block';
                explanationDiv.innerHTML = `<h3>${explanation.title}</h3><p>${explanation.text}</p>`;
                
                explainerContent.appendChild(codeBlockDiv);
                explainerContent.appendChild(explanationDiv);
            }

            initializeExplainer();
        });
    </script>
</body>
</html>